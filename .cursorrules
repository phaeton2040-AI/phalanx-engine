# General Rules
- You are an expert in TypeScript, Node.js, and Game Architecture.
- Prefer functional patterns over classes, EXCEPT for high-performance game entities where object pooling/memory management is critical.
- Use strict TypeScript. No `any`. Use `unknown` with type guards if necessary.
- Prefer Interfaces over Types for public APIs and extensible models.

# Game Dev & Performance (Context: Deterministic Lockstep)
- Avoid garbage collection spikes: reuse objects, use pools instead of `new` inside loops.
- Use `const` assertions for enums/config objects to ensure immutability.
- Math operations: use optimized libraries (e.g., your custom vector libs) instead of creating new objects.

# Testing & Networking
- When writing network code, assume deterministic lockstep constraints (no floating point non-determinism).
- Prefer isolating side-effects for easier unit testing.

# Style
- Naming: camelCase for variables/functions, PascalCase for classes/interfaces.
- File structure: Colocate tests with implementation (`foo.ts`, `foo.test.ts`).

# C# & WASM Development Rules
- Context: Shared Game Logic compiled to WebAssembly for a deterministic lockstep engine.
- Constraints: NO System.Reflection, NO Threading (Wasm is single-threaded by default), NO File System access.
- Memory: Use `Span<T>`, `Memory<T>`, and `unsafe` pointers for performance. Avoid LINQ in hot paths (update loops).
- Interop: Use `[JSExport]` and `[JSImport]` from `System.Runtime.InteropServices.JavaScript` for JS communication.
- Style: File-scoped namespaces, global usings for common types (Vector2, etc.).
